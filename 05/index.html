<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Boilerplate</title>
    <style>
        /* Stretch the canvas across the whole window with a black background */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.145.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/",
                "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.145.0/examples/jsm/loaders/GLTFLoader.js",
                "three/examples/jsm/effects/AnaglyphEffect.js": "https://unpkg.com/three@0.145.0/examples/jsm/effects/AnaglyphEffect.js"


            }
        }
    </script>

</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';



        let camera, scene, renderer, controls, effect, loader, pane, directionalLight, ambientLight;
        

        // SETTINGS and HELPER for TWEAKPANE
        window['SCENE'] = {
            anaglyph: false, // Toggle for anaglyph effect;
            poly: null, // To store the PolyCam mesh once loaded;
            rotate_poly: false, // Flag for rotation
            do_rotate_poly: function() { // Function to toggle rotation flag
                window['SCENE']['rotate_poly'] = !window['SCENE']['rotate_poly'];
            
            }

        };


        // Initialize the scene and set up basic components
        window.onload = function() {
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Initialize Tweakpane

            // Initialize Tweakpane and controls
            pane = new Pane();
            const sceneui = pane.addFolder({ title: 'Scene' });

            // Initialize Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            directionalLight = new THREE.DirectionalLight(0xffffff, 2);

            // Add Anaglyph toggle control
            sceneui.addBinding(window.SCENE, 'anaglyph', { label: 'Anaglyph Effect' });

            // Directional light controls
            sceneui.addBinding(directionalLight.position, 'x', { min: -100, max: 100, label: 'Light X' });
            sceneui.addBinding(directionalLight.position, 'y', { min: -100, max: 100, label: 'Light Y' });
            sceneui.addBinding(directionalLight.position, 'z', { min: -100, max: 100, label: 'Light Z' });
            sceneui.addBinding(directionalLight, 'intensity', { min: 0, max: 5, step: 0.1, label: 'Light Intensity' });

            // Ambient light color control
            sceneui.addBinding(ambientLight, 'color', { view: 'color', label: 'Ambient Light Color' });
            

            const polyui = pane.addFolder({ title: 'PolyCam Mesh' });

            
            // Scene
            scene = new THREE.Scene();

            // Create an AxesHelper with a size of 5 (adjust size as needed)
            const axesHelper = new THREE.AxesHelper(5);

            // Add the AxesHelper to the scene
            scene.add(axesHelper);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 0); // Move camera for better view
            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);



            // Add Lights to Scene
            scene.add(ambientLight);
            scene.add(directionalLight);

            // AnaglyphEffect
            effect = new AnaglyphEffect(renderer);
            effect.setSize(window.innerWidth, window.innerHeight);

            // Directional light for strong, directional illumination
            var directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 100, 10);
            scene.add(directionalLight);
                
             // GLTFLoader
            loader = new GLTFLoader();
            loader.load('airpod.glb', function(gltf) {

                const poly = gltf.scenes[0].children[0];
                // Scale the model for visibility
                poly.scale.set(10, 10, 10);

                poly.quaternion.w = 1;
                poly.quaternion.x = 0;
                poly.quaternion.y = 0;
                poly.quaternion.z = 0;

                poly.translateX(1)
                poly.translateY(3)

                // Set the loaded PolyCam mesh to window.SCENE.poly
                window.SCENE.poly = poly;

                // Wireframe checkbox for the PolyCam mesh
                polyui.addBinding(window.SCENE.poly.material, 'wireframe');

                // Rotation button for the PolyCam mesh
                polyui.addButton({ title: 'rotate!' }).on('click', () => {
                    window.SCENE.do_rotate_poly();
                });

                scene.add(gltf.scene);
            }, undefined, function(error) {
                console.error('An error occurred while loading the model:', error);
            });

            // Load the second (edited) model
            loader.load('originalairpod.glb', function(gltf) {  
                const original = gltf.scenes[0].children[0];
                // Scale the model
                original.scale.set(10, 10, 10);
                
                original.quaternion.w = 1;
                original.quaternion.x = 0;
                original.quaternion.y = 0;
                original.quaternion.z = 0;

                original.translateX (-1);
                original.translateY(3);

                scene.add(gltf.scene);

            }, undefined, function(error) {
                console.error('An error occurred while loading the model:', error);
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Call animate function
            animate();
        };

        // Adjusts renderer and camera aspect ratio on window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            effect.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

        // Check if PolyCam mesh is loaded
        if (window.SCENE.poly) {
            // Quaternion for a 180-degree rotation around the Y-axis
            const targetQuaternion = new THREE.Quaternion();
            targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI); // 180 degrees around Y-axis

            // Quaternion for the original orientation (identity quaternion)
            const identityQuaternion = new THREE.Quaternion(0, 0, 0, 1);

            if (window.SCENE.rotate_poly) {
                // Rotate to 180 degrees
                window.SCENE.poly.quaternion.slerp(targetQuaternion, 0.02); // Adjust 0.02 for rotation speed
            } else {
                // Reset rotation to the original orientation
                window.SCENE.poly.quaternion.slerp(identityQuaternion, 0.02);
            }
        }

            
            // Check the anaglyph toggle to decide which renderer to use
        if (window.SCENE.anaglyph) {
            effect.render(scene, camera); // Render with AnaglyphEffect
        } else {
            renderer.render(scene, camera); // Render normally
        }

        }
    </script>
</body>
</html>
