<html>

<head>
  <style>
    html,
    body {
      background-color: #000000;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden !important;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display:block;
      background-color: wheat;
    }
  </style>

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

  <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
    import { createText } from 'three/addons/webxr/Text2D.js';

    import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';
    import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';
    import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';


    var renderer, controls, scene, camera, htmlGroup, light, freezeLight, ambientLight;
    let controller1, controller1Grip, controller2, controller2Grip;
    let timeMesh, scoreMesh;
    let FPS = 1 / 60;
    let GRAVITY = -9.81;
    let BALLS = []
    let PLATES = []
    let GAME_SETTINGS = {
      MAX_PLATE_SPEED: 2,
      MAX_PLATES: 7,
      PLATE_CD_SEC: 3,
      SHOW_HIT_BOX: false,
      MIN_MAX_TTL: {min: 8, max: 12},
    }
    let CURR_PLATE_CD = 0;
    let FLOOR_LEVEL = -1;
    let SCORE = 0;
    let TIME = 0;
    let ms = 0;
    let pointerEvent = {target: '',type: 'mousedown', data: new THREE.Vector2()};
    let mousedown = false;
    let GAME_STATE = {
      isFrozen: false,
      freezeTime: 0,
      freezeMs: 0,
    }
    let currPowerUp = '';
    function MeshObjects(mesh) {
      this.object = mesh;
      this.box = new THREE.Box3(); 
      this.boxHelper = new THREE.BoxHelper();
      this.score = 0;
      this.powerup = '';
      this.PHYSICS = {
        "inty": 0,
        "yspeed": 0,
        "xspeed": 0,
        "zspeed": 0,
        "time": 0,
        "timeToLive": 0,
      }
    }
    let POWERUP_MAP = {
      freeze: {
        function: freeze,
        string: 'Freeze',
        color: 0xbddeec,
        activationChance: 0.9,
      },
      bomb: {
        function: bomb,
        string: 'Bomb',
        color: 0xffbf00,
        activationChance: 0.65,
      },
      rocket: {
        function: rocket,
        string: 'Rocket',
        color: 0x748b97,
        activationChance: 0.80,
      },
      spirit_bomb: {
        function: spirit_bomb,
        string: 'Spirit Bomb',
        color: 0x02ccfe,
        activationChance: 0.20,
      },
      hollow_purple: {
        function: hollow_purple,
        string: 'Hollow Purple',
        color: 0x330055,
        activationChance: 0.20,
      },
    }
    let POWERUPS = [
      POWERUP_MAP.freeze,
      POWERUP_MAP.bomb,
      POWERUP_MAP.rocket,
      POWERUP_MAP.hollow_purple,
      POWERUP_MAP.spirit_bomb
    ]
    window.onload = function () {

      // Three.js code goes here
      scene = new THREE.Scene({ antialias: true });
      htmlGroup = new THREE.Group();
      scene.add(htmlGroup);

      // setup the camera
      var fov = 75;
      var ratio = window.innerWidth / window.innerHeight;
      var zNear = 0.1;
      var zFar = 10000;
      camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
      camera.position.set(0, 0, 0);

      // create renderer and add canvas to DOM
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Configure VR Support
      document.body.appendChild(VRButton.createButton(renderer));
      renderer.xr.enabled = true;
      renderer.xr.updateCamera(camera);
      renderer.setAnimationLoop(animate);

      const line = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
        new THREE.LineBasicMaterial({ color: 0xff0000 })
      );
      line.scale.z = 5;

      // VR controls 
      const controllerModelFactory = new XRControllerModelFactory();

      controller1Grip = renderer.xr.getControllerGrip(0);
      controller1Grip.add(controllerModelFactory.createControllerModel(controller1Grip));
      scene.add(controller1Grip);
      controller1 = renderer.xr.getController(0);
      controller1.add(line.clone());
      scene.add(controller1);
      controller1.userData.prevPos = new THREE.Vector3();
      controller1.userData.prevQuat = new THREE.Quaternion();

      controller2Grip = renderer.xr.getControllerGrip(1);
      controller2Grip.add(controllerModelFactory.createControllerModel(controller2Grip));
      scene.add(controller2Grip);
      controller2 = renderer.xr.getController(1);
      controller2.add(line.clone());
      scene.add(controller2);

      // Controller Squeeze event
      controller1.addEventListener('selectstart', (event) => {
        onSelectStart(event);
      });
      controller2.addEventListener('selectstart', (event) => {
        onSelectStart(event);
      });

      controller1.addEventListener('selectend', (event) => {
        onSelectEnd(event);
      });

      controller2.addEventListener('selectend', (event) => {
        onSelectEnd(event);
      });

      //setup lights
      ambientLight = new THREE.AmbientLight();
      scene.add(ambientLight);

      light = new THREE.DirectionalLight(0xeeaf61, 5.0);
      light.position.set(100, 20, 0);
      scene.add(light);

      freezeLight = new THREE.AmbientLight(0x739bd0);
      freezeLight.position.set(0, 5, -2);

      // Create floor

      let floorGeometry = new THREE.PlaneGeometry(1000, 1000, 15, 15);
      let floorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, wireframe: false });
      floorMaterial.side = THREE.BackSide;
      let floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.position.set(0, FLOOR_LEVEL, 0);
      floor.rotation.x = Math.PI / 2;

      scene.add(floor);


      //configure Sphere
      var geometry = new THREE.SphereGeometry(5, 32, 16);
      var material = new THREE.MeshStandardMaterial({ color: 0x7851A9, wireframe: false });

      var sphere = new THREE.Mesh(geometry, material);
      sphere.translateZ(-50);
      sphere.translateY(20);
      scene.add(sphere);
      let object = new MeshObjects(sphere);
      sphere.geometry.computeBoundingBox();
      object.box.copy(sphere.geometry.boundingBox).applyMatrix4(sphere.matrixWorld);
      object.boxHelper = new THREE.BoxHelper(sphere, 0xff00ff);
      BALLS.push(object);

      // Tweakpane
      let pane = new Pane();
      let paneDomElemet = pane.containerElem_;
      let sceneui = pane.addFolder({title:"Game Options"});
      sceneui.addBinding(GAME_SETTINGS, 'MAX_PLATES', {
        step: 1,
        min: 0,
        max: 15,
      })
      sceneui.addBinding(GAME_SETTINGS, 'MAX_PLATE_SPEED', {
        step: 0.5,
        min: 1,
        max: 10,
      })
      sceneui.addBinding(GAME_SETTINGS, 'PLATE_CD_SEC', {
        step: 0.5,
        min: 0.5,
        max: 5,
      })
      sceneui.addButton({title: "Freeze Debug"}).on('click', freeze);
      sceneui.addButton({title: 'Toggle Hit Boxes'}).on('click', hitboxtoggle);
      sceneui.addButton({title:'Reset'}).on('click', reset);

      let htmlMesh = new HTMLMesh(paneDomElemet);
      htmlMesh.position.set(0, 2, 1);
      htmlMesh.scale.setScalar(5);
      htmlMesh.rotation.y += Math.PI;
      htmlGroup.add(htmlMesh);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enable;
      controls.update();

    };
    function hitboxtoggle() {
      GAME_SETTINGS.SHOW_HIT_BOX = !GAME_SETTINGS.SHOW_HIT_BOX;
      if (GAME_SETTINGS.SHOW_HIT_BOX) {
        BALLS.forEach((ball_mesh_object) => {
          let boxHelper = ball_mesh_object.boxHelper;
          scene.add(boxHelper);
        });
        PLATES.forEach((plate_mesh_object) => {
          let boxHelper = plate_mesh_object.boxHelper;
          scene.add(boxHelper);
        });
      } else {
        BALLS.forEach((ball_mesh_object) => {
          let boxHelper = ball_mesh_object.boxHelper;
          scene.remove(boxHelper);
        });
        PLATES.forEach((plate_mesh_object) => {
          let boxHelper = plate_mesh_object.boxHelper;
          scene.remove(boxHelper);
        });
      }
    }
    function reset() {
      BALLS.forEach((ball_mesh_object) => {
        deleteMeshObject(ball_mesh_object);
      });
      PLATES.forEach((plate_mesh_object) => {
        deleteMeshObject(plate_mesh_object);
      });
      BALLS = [];
      PLATES = [];
      CURR_PLATE_CD = 0;
      TIME = 0;
      SCORE = 0;
      ms = 0;
    }
    function deleteMeshObject(mesh_object) {
      let object = mesh_object.object;
      let boxHelper = mesh_object.boxHelper;
      scene.remove(object);
      scene.remove(boxHelper);
      object.geometry.dispose();
      object.material.dispose();
      boxHelper.dispose();
    }
    function onSelectStart(event) {
      let controller = event.target;
      // Raycasting code logic inspired by InteractiveGroup.js (Three.js - Mr doob)
      let raycaster = new THREE.Raycaster();
      raycaster.setFromXRController(controller);
      let intersects = raycaster.intersectObjects(htmlGroup.children, false);
      if (intersects.length > 0) {
        let intersectObject = intersects[0];
        let htmlObject = intersectObject.object;
        let uvCoords = intersectObject.uv;
        let pointer = new THREE.Vector2();
        pointer.set(uvCoords.x, 1 - uvCoords.y);
        pointerEvent = {target: htmlObject, type: 'click', data: pointer};
        mousedown = true;
        return;
      }
      let color = 0xffffff;
      let powerup = '';
      if (currPowerUp != '') {
        powerup = currPowerUp;
        currPowerUp = '';
        color = powerup.color;
      }
      let geometry = new THREE.SphereGeometry(0.2, 32, 16);
      let material = new THREE.MeshStandardMaterial({ color: color, wireframe: false });
      let ball = new THREE.Mesh(geometry, material);
      let object = new MeshObjects(ball);
      object.powerup = powerup;
      const boxHelper = new THREE.BoxHelper(ball, 0xFF00FF);
      controller.add(ball);
      ball.position.set(0, 0, 0);
      controller.userData.prevPos = controller.position.clone();
      controller.userData.prevQuat = controller.quaternion.clone();
      controller.userData.selected = object;
    };

    function onSelectEnd(event) {
      let controller = event.target;
      let object = controller.userData.selected;
      if (mousedown) {
        let htmlObject = pointerEvent.target;
        htmlObject.dispatchEvent(pointerEvent);
        mousedown = false;
        console.log(pointerEvent);
        return;
      }
      if (object !== undefined) {
        let sphere = object.object;
        let position = new THREE.Vector3();
        sphere.getWorldPosition(position);
        scene.add(sphere);
        sphere.geometry.computeBoundingBox();
        object.box.copy(sphere.geometry.boundingBox).applyMatrix4(sphere.matrixWorld);
        object.boxHelper = new THREE.BoxHelper(sphere, 0xff00ff);
        if (GAME_SETTINGS.SHOW_HIT_BOX) {
          scene.add(object.boxHelper);
        }
        sphere.position.x = position.x;
        sphere.position.y = position.y;
        sphere.position.z = position.z;
        const prevPos = controller.userData.prevPos;
        const currPos = position;
        // Change in Quaternion: From ChatGPT
        // let deltaQuat =  new THREE.Quaternion().multiplyQuaternions(currQuat.clone(), prevQuat.clone().invert())
        // let angularVelocity = {
        //   x: 2 * deltaQuat.x / FPS,
        //   y: 2 * deltaQuat.y / FPS,
        //   z: 2 * deltaQuat.z / FPS,
        // }
        // console.log(angularVelocity);
        // let crossProd = new THREE.Vector3(angularVelocity.x, angularVelocity.y, angularVelocity.z).cross(new THREE.Vector3(position.x, position.y, position.z));
        object.PHYSICS.xspeed = ((currPos.x - prevPos.x) / FPS);
        object.PHYSICS.zspeed = ((currPos.z - prevPos.z) / FPS);
        object.PHYSICS.yspeed = ((currPos.y - prevPos.y) / FPS);
        object.PHYSICS.inty = position.y;
        // document.getElementById("controllerInfo").innerHTML = controller.position.toArray().toString();
        BALLS.push(object);
        controller.userData.selected = undefined;
        controller.userData.prevPos = new THREE.Vector3();
        controller.userData.prevQuat = new THREE.Quaternion();
      }
    };

    // Get Random from min to max: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
    function getRandom(min, max) {
      return Math.random() * (max - min) + min;
    }

    function createPlate() {
      let powerupFactor = Math.random();
      let platePower = '';
      let color = 0x7851A9;
      if (powerupFactor < 1) {
        let randomInt = Math.floor(getRandom(0, POWERUPS.length));
        let activationChance = Math.random();
        platePower = POWERUP_MAP.freeze;
        color = platePower.color;
        // if (activationChance < POWERUPS[randomInt].activationChance) {
        //   // platePower = POWERUPS[randomInt];
        //   platePower = POWERUP_MAP.freeze;
        //   color = platePower.color;
        // }
      }
      let geometry = new THREE.CircleGeometry(0.35, 32);
      let material = new THREE.MeshStandardMaterial({ color: color, wireframe: false });
      let plate = new THREE.Mesh(geometry, material);
      plate.geometry.computeBoundingBox();
      let plateSpeed = getRandom(1, GAME_SETTINGS.MAX_PLATE_SPEED);
      let layer = Math.floor(getRandom(1, 4));
      plate.translateY(layer);
      plate.translateZ(-3);
      if (layer % 2 == 0) {
        plateSpeed *= -1;
        plate.translateX(5);
      } else {
        plate.translateX(-5)
      }
      let timeToLive = Math.floor(getRandom(GAME_SETTINGS.MIN_MAX_TTL.min, GAME_SETTINGS.MIN_MAX_TTL.max));
      scene.add(plate);
      let object = new MeshObjects(plate);
      object.powerup = platePower;
      object.PHYSICS = {
        "yspeed": 0,
        "xspeed": plateSpeed,
        "zspeed": 0,
        "time": 0,
        "timeToLive": timeToLive * 60,
      }
      object.score = layer + Math.round(plateSpeed);
      object.box.copy(plate.geometry.boundingBox).applyMatrix4(plate.matrixWorld);
      object.boxHelper = new THREE.BoxHelper(plate, 0xff00ff);
      if (GAME_SETTINGS.SHOW_HIT_BOX) {
        scene.add(object.boxHelper);
      }
      PLATES.push(object);
    }
    function plateHit(ball_mesh_object, plate_mesh_object) {
      let ball = ball_mesh_object.object;
      let plate = plate_mesh_object.object;
      let ballPowerup = ball_mesh_object.powerup;
      let platePowerup = plate_mesh_object.powerup;
      let ttlBuff = 1;
      let powerUpBuff = 1;
      if (plate_mesh_object.PHYSICS.time / plate_mesh_object.PHYSICS.timeToLive > 0.66) {
        ttlBuff = 2;
      }
      if (ballPowerup != '') {
        let powerupFunction = ballPowerup.function;
        powerupFunction(ball_mesh_object);
        currPowerUp = '';
      }
      if (platePowerup != '') {
        currPowerUp = platePowerup;
        powerUpBuff = 2;
      }
      SCORE += (plate_mesh_object.score * ttlBuff * powerUpBuff);
      deleteMeshObject(plate_mesh_object);
      // let qEnd = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0).normalize(), Math.PI);
      // plate.quaternion.slerp(qEnd, 0.1);
    }

    function freeze(object) {
      if (!GAME_STATE.isFrozen) {
        GAME_STATE.freezeMs = 0;
        scene.remove(ambientLight);
        scene.add(freezeLight);
      }
      GAME_STATE.isFrozen = true;
      GAME_STATE.freezeTime = 3;
      return;
    }

    function bomb(object) {
      return;
    }

    function rocket(object) {
      return;
    }

    function spirit_bomb(object) {
      return;
    }

    function hollow_purple(object) {
      return;
    }

    function animate() {
      controller1.userData.prevPos = controller1.position.clone();
      controller2.userData.prevPos = controller2.position.clone();
      if (!GAME_STATE.isFrozen) {
        if (PLATES.length < GAME_SETTINGS.MAX_PLATES && CURR_PLATE_CD <= 0) {
          CURR_PLATE_CD = GAME_SETTINGS.PLATE_CD_SEC * 60;
          createPlate();
        } else if (CURR_PLATE_CD > 0) {
          CURR_PLATE_CD -= 1;
        }
        for (let i = 0; i < PLATES.length; i++) {
          let plate_mesh_object = PLATES[i];
          let plate = plate_mesh_object.object;
          let plate_physics = plate_mesh_object.PHYSICS;
          let xdisplacement = plate_physics.xspeed * FPS;
          plate_mesh_object.box.copy(plate.geometry.boundingBox).applyMatrix4(plate.matrixWorld);
          if (GAME_SETTINGS.SHOW_HIT_BOX) {
            plate_mesh_object.boxHelper.update();
          }
          plate.position.x += xdisplacement;
          if (Math.abs(plate.position.x) > 5) {
            plate_physics.xspeed *= -1;
          }
          plate_physics.time += 1;
          let ttl = plate_physics.timeToLive;
          let currTime = plate_physics.time;
          let power = plate_mesh_object.powerup;
          if (ttl <= currTime) {
            deleteMeshObject(plate_mesh_object);
            PLATES.splice(i, 1);
          } else if (currTime/ttl > 0.33 && currTime/ttl < 0.66) {
            if (power == '') plate.material.color.set(0x0000ff);
          } else if (currTime/ttl > 0.66) {
            if (power == '') plate.material.color.set(0xff0000);
          }
        }
      }
      for (let i = 0; i < BALLS.length; i++) {
        let ball_mesh_object = BALLS[i];
        let ball = ball_mesh_object.object;
        let ball_physics = ball_mesh_object.PHYSICS;
        ball_mesh_object.box.copy(ball.geometry.boundingBox).applyMatrix4(ball.matrixWorld);
        if (GAME_SETTINGS.SHOW_HIT_BOX) {
          ball_mesh_object.boxHelper.update();
        }
        if (ball.position.y > FLOOR_LEVEL) {
          let tempXSpeed = ball_physics.xspeed;
          let tempZSpeed = ball_physics.zspeed;
          document.getElementById("myInfo").innerHTML = JSON.stringify({xspeed: tempXSpeed, zspeed: tempZSpeed});
          let xdisplacement = ball_physics.xspeed * FPS;
          ball.position.x += xdisplacement;
          let zdisplacement = ball_physics.zspeed * FPS;
          ball.position.z += zdisplacement;
          ball_physics.time += FPS;
          let ydisplacement = (ball_physics.yspeed * ball_physics.time) + (0.5 * GRAVITY * (ball_physics.time * ball_physics.time));
          if (ydisplacement + ball_physics.inty < FLOOR_LEVEL) {
            ball.position.y = FLOOR_LEVEL;
          } else {
            ball.position.y = ball_physics.inty + ydisplacement;
          }
          // plateHit(ball_mesh_object, PLATES[0]);
        } else {
          ball_physics.yspeed = 0;
          ball_physics.time = 0;
          ball.material.opacity = 0.5;
          deleteMeshObject(ball_mesh_object);
          BALLS.splice(i, 1);
        }
        let ball_box = ball_mesh_object.box;
        for (let j = 0; j < PLATES.length; j++) {
          let plate_mesh_object = PLATES[j];
          let plate_box = plate_mesh_object.box;
          if (ball_box.intersectsBox(plate_box)) {
            ball.material.color.set(0x00ff00);
            PLATES.splice(j, 1);
            plateHit(ball_mesh_object, plate_mesh_object);
          }
        }
      }
      htmlGroup.children.forEach((htmlMesh) => {
        htmlMesh.material.map.update();
      });
      if (GAME_STATE.freezeTime < 0) {
        GAME_STATE.isFrozen = false;
        GAME_STATE.freezeTime = 3;
        GAME_STATE.freezeMs = 0;
        scene.remove(freezeLight);
        scene.add(ambientLight);
      }
      if (!GAME_STATE.isFrozen) {
        ms += 1;
        if (ms == 60) {
          TIME += 1;
          ms = 0;
        }
        timeMesh = createText("Time: " + TIME.toString(), 1);
      } else {
        timeMesh = createText("FREEZE: " + GAME_STATE.freezeTime.toString(), 1);
        GAME_STATE.freezeMs += 1;
        if (GAME_STATE.freezeMs == 60) {
          GAME_STATE.freezeTime -= 1;
          GAME_STATE.freezeMs =0;
        }
      }
      scoreMesh = createText("Score: " + SCORE.toString(), 1);
      timeMesh.position.set(0, 5, -10);
      scoreMesh.position.set(0, 3.5, -10);
      scene.add(timeMesh);
      scene.add(scoreMesh);
      renderer.render(scene, camera);
      scene.remove(timeMesh);
      scene.remove(scoreMesh);
    };
  </script>
</head>

<body>
  <div id="info">"The value for number is: " <span id="myInfo"></span> <span id="controllerInfo"></span></div>
</body>

</html>