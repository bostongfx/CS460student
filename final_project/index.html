<html>

<head>
  <style>
    html,
    body {
      background-color: #000000;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden !important;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display:block;
      background-color: wheat;
    }
  </style>

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

  <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
    import { createText } from 'three/addons/webxr/Text2D.js';

    import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';
    import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';
    import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';


    var renderer, controls, scene, camera, htmlGroup;
    let controller1, controller1Grip, controller2, controller2Grip;
    let FPS = 1 / 60;
    let GRAVITY = -9.81;
    let BALLS = []
    let PLATES = []
    let MAX_PLATES = 7;
    let PLATE_CD = 120;
    let CURR_PLATE_CD = 0;
    let FLOOR_LEVEL = -1;
    let SCORE = 0;
    let TIME = 0;
    let ms = 0;
    function MeshObjects(mesh) {
      this.object = mesh;
      this.box = new THREE.Box3(); 
      this.boxHelper = new THREE.BoxHelper();
      this.score = 0;
      this.PHYSICS = {
        "inty": 0,
        "yspeed": 0,
        "xspeed": 0,
        "zspeed": 0,
        "time": 0,
        "timeToLive": 0,
      }
    }
    window.onload = function () {

      // Three.js code goes here
      scene = new THREE.Scene({ antialias: true });
      htmlGroup = new THREE.Group();
      scene.add(htmlGroup);

      // setup the camera
      var fov = 75;
      var ratio = window.innerWidth / window.innerHeight;
      var zNear = 0.1;
      var zFar = 10000;
      camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
      camera.position.set(0, 0, 0);

      // create renderer and add canvas to DOM
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Configure VR Support
      document.body.appendChild(VRButton.createButton(renderer));
      renderer.xr.enabled = true;
      renderer.xr.updateCamera(camera);
      renderer.setAnimationLoop(animate);

      const line = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
        new THREE.LineBasicMaterial({ color: 0xff0000 })
      );
      line.scale.z = 5;

      // VR controls 
      const controllerModelFactory = new XRControllerModelFactory();

      controller1Grip = renderer.xr.getControllerGrip(0);
      controller1Grip.add(controllerModelFactory.createControllerModel(controller1Grip));
      scene.add(controller1Grip);
      controller1 = renderer.xr.getController(0);
      controller1.add(line.clone());
      scene.add(controller1);
      controller1.userData.prevPos = new THREE.Vector3();
      controller1.userData.prevQuat = new THREE.Quaternion();

      controller2Grip = renderer.xr.getControllerGrip(1);
      controller2Grip.add(controllerModelFactory.createControllerModel(controller2Grip));
      scene.add(controller2Grip);
      controller2 = renderer.xr.getController(1);
      controller2.add(line.clone());
      scene.add(controller2);

      // Controller Squeeze event
      controller1.addEventListener('selectstart', (event) => {
        onSelectStart(event);
      });
      controller2.addEventListener('selectstart', (event) => {
        onSelectStart(event);
      });

      controller1.addEventListener('selectend', (event) => {
        onSelectEnd(event);
      });

      controller2.addEventListener('selectend', (event) => {
        onSelectEnd(event);
      });

      //setup lights
      var ambientLight = new THREE.AmbientLight();
      scene.add(ambientLight);

      var light = new THREE.DirectionalLight(0xeeaf61, 5.0);
      light.position.set(100, 20, 0);
      scene.add(light);

      // Create floor

      let floorGeometry = new THREE.PlaneGeometry(1000, 1000, 15, 15);
      let floorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, wireframe: false });
      floorMaterial.side = THREE.BackSide;
      let floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.position.set(0, FLOOR_LEVEL, 0);
      floor.rotation.x = Math.PI / 2;

      scene.add(floor);


      //configure Sphere
      var geometry = new THREE.SphereGeometry(5, 32, 16);
      var material = new THREE.MeshStandardMaterial({ color: 0x7851A9, wireframe: false });

      var sphere = new THREE.Mesh(geometry, material);
      sphere.translateZ(-50);
      sphere.translateY(20);
      scene.add(sphere);
      let object = new MeshObjects(sphere);
      sphere.geometry.computeBoundingBox();
      object.box.copy(sphere.geometry.boundingBox).applyMatrix4(sphere.matrixWorld);
      object.boxHelper = new THREE.BoxHelper(sphere, 0xff00ff);
      scene.add(object.boxHelper);
      BALLS.push(object);
      
      // GUI Setup
      // const interactiveGroup = new InteractiveGroup();
			// interactiveGroup.listenToPointerEvents( renderer, camera );
			// interactiveGroup.listenToXRControllerEvents( controller1 );
			// interactiveGroup.listenToXRControllerEvents( controller2 );
      // scene.add(interactiveGroup);

      // Tweakpane
      let pane = new Pane();
      let paneDomElemet = pane.containerElem_;
      paneDomElemet.style.visibility = 'hidden';
      let sceneui = pane.addFolder({title:"Options"});
      sceneui.addBinding(floor.material, 'color', {label: "Color"});
      sceneui.addButton({title:'Change Material!'}).on('click', () => {
        console.log("Clicked");
        floor.material.color.set(0xff0000);
      });

      let htmlMesh = new HTMLMesh(paneDomElemet);
      htmlMesh.position.set(0, 2, -0.5);
      htmlMesh.scale.setScalar(2);
      // htmlMesh.rotation.x = Math.PI;
      console.log(htmlMesh);
      htmlGroup.add(htmlMesh);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enable;
      controls.update();

    };
    function onSelectStart(event) {
      let controller = event.target;
      // Raycasting code logic inspired by InteractiveGroup.js (Three.js - Mr doob)
      let raycaster = new THREE.Raycaster();
      raycaster.setFromXRController(controller);
      let intersects = raycaster.intersectObjects(htmlGroup.children, false);
      if (intersects.length > 0) {
        let intersectObject = intersects[0];
        let htmlObject = intersectObject.object;
        let uvCoords = intersectObject.uv;

        let pointerEvent = { type: 'mousedown', data: new THREE.Vector2(uvCoords.x, 1 - uvCoords.y)};
        htmlObject.dispatchEvent(pointerEvent);
        console.log(htmlObject);
      }
      let geometry = new THREE.SphereGeometry(0.2, 32, 16);
      let material = new THREE.MeshStandardMaterial({ color: 0xffffff, wireframe: false });
      let ball = new THREE.Mesh(geometry, material);
      let object = new MeshObjects(ball);
      const boxHelper = new THREE.BoxHelper(ball, 0xFF00FF);
      scene.add(boxHelper);
      controller.add(ball);
      ball.position.set(0, 0, 0);
      controller.userData.prevPos = controller.position.clone();
      controller.userData.prevQuat = controller.quaternion.clone();
      controller.userData.selected = object;
    };

    function onSelectEnd(event) {
      let controller = event.target;
      let object = controller.userData.selected;
      if (object !== undefined) {
        let sphere = object.object;
        let position = new THREE.Vector3();
        sphere.getWorldPosition(position);
        scene.add(sphere);
        sphere.geometry.computeBoundingBox();
        object.box.copy(sphere.geometry.boundingBox).applyMatrix4(sphere.matrixWorld);
        object.boxHelper = new THREE.BoxHelper(sphere, 0xff00ff);
        scene.add(object.boxHelper);
        sphere.position.x = position.x;
        sphere.position.y = position.y;
        sphere.position.z = position.z;
        const prevPos = controller.userData.prevPos;
        const currPos = position;
        // Change in Quaternion: From ChatGPT
        // let deltaQuat =  new THREE.Quaternion().multiplyQuaternions(currQuat.clone(), prevQuat.clone().invert())
        // let angularVelocity = {
        //   x: 2 * deltaQuat.x / FPS,
        //   y: 2 * deltaQuat.y / FPS,
        //   z: 2 * deltaQuat.z / FPS,
        // }
        // console.log(angularVelocity);
        // let crossProd = new THREE.Vector3(angularVelocity.x, angularVelocity.y, angularVelocity.z).cross(new THREE.Vector3(position.x, position.y, position.z));
        object.PHYSICS.xspeed = ((currPos.x - prevPos.x) / FPS);
        object.PHYSICS.zspeed = ((currPos.z - prevPos.z) / FPS);
        object.PHYSICS.yspeed = ((currPos.y - prevPos.y) / FPS);
        object.PHYSICS.inty = position.y;
        // document.getElementById("controllerInfo").innerHTML = controller.position.toArray().toString();
        BALLS.push(object);
        controller.userData.selected = undefined;
        controller.userData.prevPos = new THREE.Vector3();
        controller.userData.prevQuat = new THREE.Quaternion();
      }
    };

    // Get Random from min to max: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
    function getRandom(min, max) {
      return Math.random() * (max - min) + min;
    }

    function createPlate() {
      let geometry = new THREE.CircleGeometry(0.35, 32);
      let material = new THREE.MeshStandardMaterial({ color: 0x7851A9, wireframe: false });
      let plate = new THREE.Mesh(geometry, material);
      plate.geometry.computeBoundingBox();
      let plateSpeed = getRandom(1, 2);
      let layer = Math.floor(getRandom(1, 4));
      plate.translateY(layer);
      plate.translateZ(-3);
      if (layer % 2 == 0) {
        plateSpeed *= -1;
        plate.translateX(5);
      } else {
        plate.translateX(-5)
      }
      let timeToLive = Math.floor(getRandom(8, 12));
      scene.add(plate);
      let object = new MeshObjects(plate);
      object.PHYSICS = {
        "yspeed": 0,
        "xspeed": plateSpeed,
        "zspeed": 0,
        "time": 0,
        "timeToLive": timeToLive * 60,
      }
      object.score = layer + Math.round(plateSpeed);
      object.box.copy(plate.geometry.boundingBox).applyMatrix4(plate.matrixWorld);
      object.boxHelper = new THREE.BoxHelper(plate, 0xff00ff);
      scene.add(object.boxHelper);
      PLATES.push(object);
    }
    function plateHit(ball_mesh_object, plate_mesh_object) {
      let ball = ball_mesh_object.object;
      let plate = plate_mesh_object.object;
      let ttlBuff = 1;
      if (plate_mesh_object.PHYSICS.time / plate_mesh_object.PHYSICS.timeToLive > 0.66) {
        ttlBuff = 1.5;
      }
      SCORE += (plate_mesh_object.score * ttlBuff);
      scene.remove(plate);
      scene.remove(plate_mesh_object.boxHelper);
      // let qEnd = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0).normalize(), Math.PI);
      // plate.quaternion.slerp(qEnd, 0.1);
    }

    function animate() {
      controller1.userData.prevPos = controller1.position.clone();
      controller2.userData.prevPos = controller2.position.clone();
      if (PLATES.length < MAX_PLATES && CURR_PLATE_CD <= 0) {
        CURR_PLATE_CD = PLATE_CD;
        createPlate();
      } else if (CURR_PLATE_CD > 0) {
        CURR_PLATE_CD -= 1;
      }
      for (let i = 0; i < PLATES.length; i++) {
        let plate_mesh_object = PLATES[i];
        let plate = plate_mesh_object.object;
        let plate_physics = plate_mesh_object.PHYSICS;
        let xdisplacement = plate_physics.xspeed * FPS;
        plate_mesh_object.box.copy(plate.geometry.boundingBox).applyMatrix4(plate.matrixWorld);
        plate_mesh_object.boxHelper.update();
        plate.position.x += xdisplacement;
        if (Math.abs(plate.position.x) > 5) {
          plate_physics.xspeed *= -1;
        }
        plate_physics.time += 1;
        let ttl = plate_physics.timeToLive;
        let currTime = plate_physics.time;
        if (ttl <= currTime) {
          scene.remove(plate);
          scene.remove(plate_mesh_object.boxHelper);
          PLATES.splice(i, 1);
        } else if (currTime/ttl > 0.33 && currTime/ttl < 0.66) {
          plate.material.color.set(0x0000ff)
        } else if (currTime/ttl > 0.66) {
          plate.material.color.set(0xff0000);
        }
        // let qEnd = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0).normalize(), Math.PI);
        // plate.quaternion.slerp(qEnd, 0.1);
      }
      for (let i = 0; i < BALLS.length; i++) {
        let ball_mesh_object = BALLS[i];
        let ball = ball_mesh_object.object;
        let ball_physics = ball_mesh_object.PHYSICS;
        ball_mesh_object.box.copy(ball.geometry.boundingBox).applyMatrix4(ball.matrixWorld);
        ball_mesh_object.boxHelper.update();
        if (ball.position.y > FLOOR_LEVEL) {
          let tempXSpeed = ball_physics.xspeed;
          let tempZSpeed = ball_physics.zspeed;
          document.getElementById("myInfo").innerHTML = JSON.stringify({xspeed: tempXSpeed, zspeed: tempZSpeed});
          let xdisplacement = ball_physics.xspeed * FPS;
          ball.position.x += xdisplacement;
          let zdisplacement = ball_physics.zspeed * FPS;
          ball.position.z += zdisplacement;
          ball_physics.time += FPS;
          let ydisplacement = (ball_physics.yspeed * ball_physics.time) + (0.5 * GRAVITY * (ball_physics.time * ball_physics.time));
          if (ydisplacement + ball_physics.inty < FLOOR_LEVEL) {
            ball.position.y = FLOOR_LEVEL;
          } else {
            ball.position.y = ball_physics.inty + ydisplacement;
          }
        } else {
          ball_physics.yspeed = 0;
          ball_physics.time = 0;
          scene.remove(ball);
          scene.remove(ball_mesh_object.boxHelper);
          ball.material.opacity = 0.5;
          BALLS.splice(i, 1);
        }
        let ball_box = ball_mesh_object.box;
        for (let j = 0; j < PLATES.length; j++) {
          let plate_mesh_object = PLATES[j];
          let plate_box = plate_mesh_object.box;
          if (ball_box.intersectsBox(plate_box)) {
            ball.material.color.set(0x00ff00);
            PLATES.splice(j, 1);
            plateHit(ball_mesh_object, plate_mesh_object);
          }
        }
      }
      ms += 1;
      if (ms == 60) {
        TIME += 1;
        ms = 0;
      }
      let timeMesh = createText("Time: " + TIME.toString(), 1);
      let scoreMesh = createText("Score: " + SCORE.toString(), 1);
      timeMesh.position.set(0, 5, -10);
      scoreMesh.position.set(0, 3.5, -10);
      scene.add(timeMesh);
      scene.add(scoreMesh);
      renderer.render(scene, camera);
      scene.remove(timeMesh);
      scene.remove(scoreMesh);
    };
  </script>
</head>

<body>
  <div id="info">"The value for number is: " <span id="myInfo"></span> <span id="controllerInfo"></span></div>
</body>

</html>